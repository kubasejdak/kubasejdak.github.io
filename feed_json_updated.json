{"version": "https://jsonfeed.org/version/1", "title": "kubasejdak.com", "home_page_url": "https://kubasejdak.github.io/", "feed_url": "https://kubasejdak.github.io/feed_json_updated.json", "description": "Personal website of Kuba Sejdak", "icon": null, "authors": [], "language": "en", "items": [{"id": "https://kubasejdak.github.io/blog/19-reasons-why-cmake-is-actually-awesome/", "url": "https://kubasejdak.github.io/blog/19-reasons-why-cmake-is-actually-awesome/", "title": "19 reasons why CMake is actually awesome", "content_html": "<h1>19 reasons why CMake is actually awesome</h1>\n<p>Topic of CMake is extremely controversial in the C/C++ community. People say that it is hard to properly set the include\npaths, that syntax is archaic or that managing dependencies is a nightmare. Expressing public hate for CMake has become\na way of integrating with other software developers on the Internet.</p>\n<p>And I partially understand that statements. Before CMake 3.x (aka Modern CMake) we were forced to use\n<code>include_directories()</code> or manually set installation paths for libraries, that were not supported by default in CMake.\nSyntax was a bit oldish and managing the compilation flags usually lead to headaches.</p>\n<p>But since CMake 3.x (released on 06.2014) we have way more flexible and elegant ways of creating build systems with\nCMake. Almost all cons are gone in favor of the new modern solutions. The only problem is that once a bad impression was\nmade, it is really hard to change it. After all, who would like to invest in studying new features and best practices of\na build system?! Well I do, and let me share with you 19 reasons, why CMake is actually awesome and you should give it a\ntry again.</p>", "image": "https://kubasejdak.github.io/assets/images/social/blog/posts/19-reasons-why-cmake-is-actually-awesome.png", "date_modified": "2025-06-07T22:56:12+00:00", "authors": [{"name": "Kuba Sejdak"}], "tags": null}, {"id": "https://kubasejdak.github.io/blog/how-to-cross-compile-for-embedded-with-cmake-like-a-champ/", "url": "https://kubasejdak.github.io/blog/how-to-cross-compile-for-embedded-with-cmake-like-a-champ/", "title": "How to cross-compile for embedded with CMake like a champ", "content_html": "<h1>How to cross-compile for embedded with CMake like a champ</h1>\n<p>The power of CMake lies in the fact, that it is both cross-platform in terms of build host and allows cross-compilation\nfor different targets at the same time. In other words, we can build projects from any platform to any platform as long\nas we have proper tools (usually called toolchains). However many people don\u2019t know about this and try to come up with a\nsophisticated handmade solution or put complex logic into <code>CMakeLists.txt</code> files in order to setup the environment.\nToday I\u2019m going to show you how to enable cross-compilation for your project with CMake, basing on the embedded platform\ncase.</p>", "image": "https://kubasejdak.github.io/assets/images/social/blog/posts/how-to-cross-compile-for-embedded-with-cmake-like-a-champ.png", "date_modified": "2025-06-07T22:56:12+00:00", "authors": [{"name": "Kuba Sejdak"}], "tags": null}, {"id": "https://kubasejdak.github.io/blog/how-to-join-repositories-in-cmake/", "url": "https://kubasejdak.github.io/blog/how-to-join-repositories-in-cmake/", "title": "How to join repositories in CMake", "content_html": "<h1>How to join repositories in CMake</h1>\n<p>Sometimes there is a need in a project to use directly some other repository (local or external). This means, that we\nwant to be able to incorporate parts (or all) of sources of the imported repository into our build system. Usually, in\nsuch a case we would also like to track which version is used at a given time.</p>\n<p>We can solve this problem in a few ways, e.g. by using:</p>\n<ul>\n<li>git submodules,</li>\n<li>git subtree,</li>\n<li>CMake <code>FetchContent</code>,</li>\n<li>CMake <code>ExternalProject</code>.</li>\n</ul>\n<p>First two are handled by the version control system and the last two are handled by the build system. Each of them has\nits own strengths and weaknesses, depending on the current project needs.</p>\n<p>Today I want to briefly present how CMake allows joining repositories with its <code>FetchContent</code> and <code>ExternalProject</code>\nmodules.</p>", "image": "https://kubasejdak.github.io/assets/images/social/blog/posts/how-to-join-repositories-in-cmake.png", "date_modified": "2025-06-07T22:56:12+00:00", "authors": [{"name": "Kuba Sejdak"}], "tags": null}, {"id": "https://kubasejdak.github.io/blog/introduction-to-conan-package-manager/", "url": "https://kubasejdak.github.io/blog/introduction-to-conan-package-manager/", "title": "Introduction to Conan package manager", "content_html": "<h1>Introduction to Conan package manager</h1>\n<p>In the previous article of this series, I have listed several problems that we as developers have to deal with while\nusing dependencies to external code in our projects. These vary from version management, through cross-compilation\nissues, up to the horror of integration with our build system. Linux users are used to the comfort of working with\npackage managers, which download and install applications and libraries in our host system with simple to use\ncommand-line utilities. It would be very handy to have a tool, that does something similar for libraries in the C++\nworld. Among many previously mentioned package managers, one has stolen my heart and attention for good \u2013\n[Conan][conan].</p>", "image": "https://kubasejdak.github.io/assets/images/social/blog/posts/introduction-to-conan-package-manager.png", "date_modified": "2025-06-07T22:56:12+00:00", "authors": [{"name": "Kuba Sejdak"}], "tags": null}, {"id": "https://kubasejdak.github.io/blog/let-the-games-begin/", "url": "https://kubasejdak.github.io/blog/let-the-games-begin/", "title": "Let the games begin", "content_html": "<h1>Let the games begin</h1>\n<p>Hello hello! My name is Kuba Sejdak. I\u2019m a C++ software engineer for over 7 years. Today I realized, that I have a need\nto share my C++ journey with the world. So I decided to start a blog.</p>", "image": "https://kubasejdak.github.io/assets/images/social/blog/posts/let-the-games-begin.png", "date_modified": "2025-06-07T22:56:12+00:00", "authors": [{"name": "Kuba Sejdak"}], "tags": null}, {"id": "https://kubasejdak.github.io/blog/modern-cmake-is-like-inheritance/", "url": "https://kubasejdak.github.io/blog/modern-cmake-is-like-inheritance/", "title": "Modern CMake is like inheritance", "content_html": "<h1>Modern CMake is like inheritance</h1>\n<p>CMake has been created in 2000 by Bill Hoffman from Kitware. During the last 20 years, as of the time of this\npublication, it\u2019s been constantly evolving by adding new features and expanding its support for third-party libraries.\nBut the most significant additions were released in version 3.0 and are commonly called \u201cModern CMake\u201d. Despite being\navailable for more than 5 years, many programmers are still not using them!</p>\n<p>Today I will show you one of the greatest \u201cModern CMake\u201d feature, that behaves almost like C++ inheritance. But before\nwe get there, let me briefly explain a few fundaments.</p>", "image": "https://kubasejdak.github.io/assets/images/social/blog/posts/modern-cmake-is-like-inheritance.png", "date_modified": "2025-06-07T22:56:12+00:00", "authors": [{"name": "Kuba Sejdak"}], "tags": null}, {"id": "https://kubasejdak.github.io/blog/problems-with-external-dependencies-in-c/", "url": "https://kubasejdak.github.io/blog/problems-with-external-dependencies-in-c/", "title": "Problems with external dependencies in C++", "content_html": "<h1>Problems with external dependencies in C++</h1>\n<p>Dependencies are usually the most problematic part of the build system (next to the toolchain setup) in programming\nprojects. In C++ this is especially hard because there is no one standard build system. Many more problems arise if we\ntarget an embedded system. Other programming languages resolve this issue by having one built-in package manager\n(usually accompanied by an integrated build system). In C++ we lack both of them, so our lives are much harder.\nFortunately, there are a few third-party package managers which get more and more popular. In this series of posts, I\nwill try to convince you to start using one of them \u2013 Conan.</p>", "image": "https://kubasejdak.github.io/assets/images/social/blog/posts/problems-with-external-dependencies-in-cpp.png", "date_modified": "2025-06-07T22:56:12+00:00", "authors": [{"name": "Kuba Sejdak"}], "tags": null}, {"id": "https://kubasejdak.github.io/blog/variadic-functions--part-1-va_args-and-friends/", "url": "https://kubasejdak.github.io/blog/variadic-functions--part-1-va_args-and-friends/", "title": "Variadic functions \u2013 Part 1: va_args and friends", "content_html": "<h1>Variadic functions \u2013 Part 1: <code>va_args</code> and friends</h1>\n<p>From time to time there is a need to write a function, that accepts an unspecified number of arguments. In C++ we have\nmultiple ways of handling this depending on the context, use case and available language features. But the oldest and\nstill most commonly used mechanism is the <code>va_arg</code>.</p>\n<p>You think nothing can surprise you? Let\u2019s bet.</p>", "image": "https://kubasejdak.github.io/assets/images/social/blog/posts/variadic-functions--part-1-va_args-and-friends.png", "date_modified": "2025-06-07T22:56:12+00:00", "authors": [{"name": "Kuba Sejdak"}], "tags": null}, {"id": "https://kubasejdak.github.io/blog/variadic-functions--part-2-c11-variadic-templates/", "url": "https://kubasejdak.github.io/blog/variadic-functions--part-2-c11-variadic-templates/", "title": "Variadic functions \u2013 Part 2: C++11 variadic templates", "content_html": "<h1>Variadic functions \u2013 Part 2: C++11 variadic templates</h1>\n<p>In the previous article, we have seen an old C-style way of defining the variadic functions \u2013 via va_args macros. We\nhave also learned their weaknesses: runtime cost, strict contract between caller and the callee and lack of type safety.\nNot to mention the problem of default type promotion!</p>\n<p>Fortunately, standards committee thought this through and equipped us in C++11 with variadic templates. Let\u2019s check them\nout.</p>", "image": "https://kubasejdak.github.io/assets/images/social/blog/posts/variadic-functions--part-2-c11-variadic-templates.png", "date_modified": "2025-06-07T22:56:12+00:00", "authors": [{"name": "Kuba Sejdak"}], "tags": null}, {"id": "https://kubasejdak.github.io/blog/variadic-functions--part-3-techniques-of-variadic-templates/", "url": "https://kubasejdak.github.io/blog/variadic-functions--part-3-techniques-of-variadic-templates/", "title": "Variadic functions \u2013 Part 3: Techniques of variadic templates", "content_html": "<h1>Variadic functions \u2013 Part 3: Techniques of variadic templates</h1>\n<p>In the previous article I have shown you how variadic templates can be a type-safe alternative to va_arg macros in\ndesigning the variadic functions. Today I want to show you a few techniques of variadic templates, that can be found in\nmany codebases.</p>", "image": "https://kubasejdak.github.io/assets/images/social/blog/posts/variadic-functions--part-3-techniques-of-variadic-templates.png", "date_modified": "2025-06-07T22:56:12+00:00", "authors": [{"name": "Kuba Sejdak"}], "tags": null}]}