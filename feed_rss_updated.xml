<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"> <channel><title>kubasejdak.com</title><description>Personal website of Kuba Sejdak</description><link>https://kubasejdak.github.io/</link><atom:link href="https://kubasejdak.github.io/feed_rss_updated.xml" rel="self" type="application/rss+xml" /><language>en</language> <pubDate>Sat, 07 Jun 2025 20:56:37 -0000</pubDate> <lastBuildDate>Sat, 07 Jun 2025 20:56:37 -0000</lastBuildDate> <ttl>1440</ttl> <generator>MkDocs RSS plugin - v1.17.3</generator> <image> <url>None</url> <title>kubasejdak.com</title><link>https://kubasejdak.github.io/</link> </image> <item> <title>19 reasons why CMake is actually awesome</title> <author>Kuba Sejdak</author> <description>&lt;h1&gt;19 reasons why CMake is actually awesome&lt;/h1&gt;&lt;p&gt;Topic of CMake is extremely controversial in the C/C++ community. People say that it is hard to properly set the includepaths, that syntax is archaic or that managing dependencies is a nightmare. Expressing public hate for CMake has becomea way of integrating with other software developers on the Internet.&lt;/p&gt;&lt;p&gt;And I partially understand that statements. Before CMake 3.x (aka Modern CMake) we were forced to use&lt;code&gt;include_directories()&lt;/code&gt; or manually set installation paths for libraries, that were not supported by default in CMake.Syntax was a bit oldish and managing the compilation flags usually lead to headaches.&lt;/p&gt;&lt;p&gt;But since CMake 3.x (released on 06.2014) we have way more flexible and elegant ways of creating build systems withCMake. Almost all cons are gone in favor of the new modern solutions. The only problem is that once a bad impression wasmade, it is really hard to change it. After all, who would like to invest in studying new features and best practices ofa build system?! Well I do, and let me share with you 19 reasons, why CMake is actually awesome and you should give it atry again.&lt;/p&gt;</description><link>https://kubasejdak.github.io/blog/19-reasons-why-cmake-is-actually-awesome/</link> <pubDate>Sat, 07 Jun 2025 22:56:12 +0000</pubDate><source url="https://kubasejdak.github.io/feed_rss_updated.xml">kubasejdak.com</source><guid isPermaLink="true">https://kubasejdak.github.io/blog/19-reasons-why-cmake-is-actually-awesome/</guid> <enclosure url="https://kubasejdak.github.io/assets/images/social/blog/posts/19-reasons-why-cmake-is-actually-awesome.png" type="image/png" length="58159" /> </item> <item> <title>How to cross-compile for embedded with CMake like a champ</title> <author>Kuba Sejdak</author> <description>&lt;h1&gt;How to cross-compile for embedded with CMake like a champ&lt;/h1&gt;&lt;p&gt;The power of CMake lies in the fact, that it is both cross-platform in terms of build host and allows cross-compilationfor different targets at the same time. In other words, we can build projects from any platform to any platform as longas we have proper tools (usually called toolchains). However many people don’t know about this and try to come up with asophisticated handmade solution or put complex logic into &lt;code&gt;CMakeLists.txt&lt;/code&gt; files in order to setup the environment.Today I’m going to show you how to enable cross-compilation for your project with CMake, basing on the embedded platformcase.&lt;/p&gt;</description><link>https://kubasejdak.github.io/blog/how-to-cross-compile-for-embedded-with-cmake-like-a-champ/</link> <pubDate>Sat, 07 Jun 2025 22:56:12 +0000</pubDate><source url="https://kubasejdak.github.io/feed_rss_updated.xml">kubasejdak.com</source><guid isPermaLink="true">https://kubasejdak.github.io/blog/how-to-cross-compile-for-embedded-with-cmake-like-a-champ/</guid> <enclosure url="https://kubasejdak.github.io/assets/images/social/blog/posts/how-to-cross-compile-for-embedded-with-cmake-like-a-champ.png" type="image/png" length="45285" /> </item> <item> <title>How to join repositories in CMake</title> <author>Kuba Sejdak</author> <description>&lt;h1&gt;How to join repositories in CMake&lt;/h1&gt;&lt;p&gt;Sometimes there is a need in a project to use directly some other repository (local or external). This means, that wewant to be able to incorporate parts (or all) of sources of the imported repository into our build system. Usually, insuch a case we would also like to track which version is used at a given time.&lt;/p&gt;&lt;p&gt;We can solve this problem in a few ways, e.g. by using:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;git submodules,&lt;/li&gt;&lt;li&gt;git subtree,&lt;/li&gt;&lt;li&gt;CMake &lt;code&gt;FetchContent&lt;/code&gt;,&lt;/li&gt;&lt;li&gt;CMake &lt;code&gt;ExternalProject&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;First two are handled by the version control system and the last two are handled by the build system. Each of them hasits own strengths and weaknesses, depending on the current project needs.&lt;/p&gt;&lt;p&gt;Today I want to briefly present how CMake allows joining repositories with its &lt;code&gt;FetchContent&lt;/code&gt; and &lt;code&gt;ExternalProject&lt;/code&gt;modules.&lt;/p&gt;</description><link>https://kubasejdak.github.io/blog/how-to-join-repositories-in-cmake/</link> <pubDate>Sat, 07 Jun 2025 22:56:12 +0000</pubDate><source url="https://kubasejdak.github.io/feed_rss_updated.xml">kubasejdak.com</source><guid isPermaLink="true">https://kubasejdak.github.io/blog/how-to-join-repositories-in-cmake/</guid> <enclosure url="https://kubasejdak.github.io/assets/images/social/blog/posts/how-to-join-repositories-in-cmake.png" type="image/png" length="44427" /> </item> <item> <title>Introduction to Conan package manager</title> <author>Kuba Sejdak</author> <description>&lt;h1&gt;Introduction to Conan package manager&lt;/h1&gt;&lt;p&gt;In the previous article of this series, I have listed several problems that we as developers have to deal with whileusing dependencies to external code in our projects. These vary from version management, through cross-compilationissues, up to the horror of integration with our build system. Linux users are used to the comfort of working withpackage managers, which download and install applications and libraries in our host system with simple to usecommand-line utilities. It would be very handy to have a tool, that does something similar for libraries in the C++world. Among many previously mentioned package managers, one has stolen my heart and attention for good –[Conan][conan].&lt;/p&gt;</description><link>https://kubasejdak.github.io/blog/introduction-to-conan-package-manager/</link> <pubDate>Sat, 07 Jun 2025 22:56:12 +0000</pubDate><source url="https://kubasejdak.github.io/feed_rss_updated.xml">kubasejdak.com</source><guid isPermaLink="true">https://kubasejdak.github.io/blog/introduction-to-conan-package-manager/</guid> <enclosure url="https://kubasejdak.github.io/assets/images/social/blog/posts/introduction-to-conan-package-manager.png" type="image/png" length="48656" /> </item> <item> <title>Let the games begin</title> <author>Kuba Sejdak</author> <description>&lt;h1&gt;Let the games begin&lt;/h1&gt;&lt;p&gt;Hello hello! My name is Kuba Sejdak. I’m a C++ software engineer for over 7 years. Today I realized, that I have a needto share my C++ journey with the world. So I decided to start a blog.&lt;/p&gt;</description><link>https://kubasejdak.github.io/blog/let-the-games-begin/</link> <pubDate>Sat, 07 Jun 2025 22:56:12 +0000</pubDate><source url="https://kubasejdak.github.io/feed_rss_updated.xml">kubasejdak.com</source><guid isPermaLink="true">https://kubasejdak.github.io/blog/let-the-games-begin/</guid> <enclosure url="https://kubasejdak.github.io/assets/images/social/blog/posts/let-the-games-begin.png" type="image/png" length="37218" /> </item> <item> <title>Modern CMake is like inheritance</title> <author>Kuba Sejdak</author> <description>&lt;h1&gt;Modern CMake is like inheritance&lt;/h1&gt;&lt;p&gt;CMake has been created in 2000 by Bill Hoffman from Kitware. During the last 20 years, as of the time of thispublication, it’s been constantly evolving by adding new features and expanding its support for third-party libraries.But the most significant additions were released in version 3.0 and are commonly called “Modern CMake”. Despite beingavailable for more than 5 years, many programmers are still not using them!&lt;/p&gt;&lt;p&gt;Today I will show you one of the greatest “Modern CMake” feature, that behaves almost like C++ inheritance. But beforewe get there, let me briefly explain a few fundaments.&lt;/p&gt;</description><link>https://kubasejdak.github.io/blog/modern-cmake-is-like-inheritance/</link> <pubDate>Sat, 07 Jun 2025 22:56:12 +0000</pubDate><source url="https://kubasejdak.github.io/feed_rss_updated.xml">kubasejdak.com</source><guid isPermaLink="true">https://kubasejdak.github.io/blog/modern-cmake-is-like-inheritance/</guid> <enclosure url="https://kubasejdak.github.io/assets/images/social/blog/posts/modern-cmake-is-like-inheritance.png" type="image/png" length="43972" /> </item> <item> <title>Problems with external dependencies in C++</title> <author>Kuba Sejdak</author> <description>&lt;h1&gt;Problems with external dependencies in C++&lt;/h1&gt;&lt;p&gt;Dependencies are usually the most problematic part of the build system (next to the toolchain setup) in programmingprojects. In C++ this is especially hard because there is no one standard build system. Many more problems arise if wetarget an embedded system. Other programming languages resolve this issue by having one built-in package manager(usually accompanied by an integrated build system). In C++ we lack both of them, so our lives are much harder.Fortunately, there are a few third-party package managers which get more and more popular. In this series of posts, Iwill try to convince you to start using one of them – Conan.&lt;/p&gt;</description><link>https://kubasejdak.github.io/blog/problems-with-external-dependencies-in-c/</link> <pubDate>Sat, 07 Jun 2025 22:56:12 +0000</pubDate><source url="https://kubasejdak.github.io/feed_rss_updated.xml">kubasejdak.com</source><guid isPermaLink="true">https://kubasejdak.github.io/blog/problems-with-external-dependencies-in-c/</guid> <enclosure url="https://kubasejdak.github.io/assets/images/social/blog/posts/problems-with-external-dependencies-in-cpp.png" type="image/png" length="48288" /> </item> <item> <title>Variadic functions – Part 1: va_args and friends</title> <author>Kuba Sejdak</author> <description>&lt;h1&gt;Variadic functions – Part 1: &lt;code&gt;va_args&lt;/code&gt; and friends&lt;/h1&gt;&lt;p&gt;From time to time there is a need to write a function, that accepts an unspecified number of arguments. In C++ we havemultiple ways of handling this depending on the context, use case and available language features. But the oldest andstill most commonly used mechanism is the &lt;code&gt;va_arg&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;You think nothing can surprise you? Let’s bet.&lt;/p&gt;</description><link>https://kubasejdak.github.io/blog/variadic-functions--part-1-va_args-and-friends/</link> <pubDate>Sat, 07 Jun 2025 22:56:12 +0000</pubDate><source url="https://kubasejdak.github.io/feed_rss_updated.xml">kubasejdak.com</source><guid isPermaLink="true">https://kubasejdak.github.io/blog/variadic-functions--part-1-va_args-and-friends/</guid> <enclosure url="https://kubasejdak.github.io/assets/images/social/blog/posts/variadic-functions--part-1-va_args-and-friends.png" type="image/png" length="51512" /> </item> <item> <title>Variadic functions – Part 2: C++11 variadic templates</title> <author>Kuba Sejdak</author> <description>&lt;h1&gt;Variadic functions – Part 2: C++11 variadic templates&lt;/h1&gt;&lt;p&gt;In the previous article, we have seen an old C-style way of defining the variadic functions – via va_args macros. Wehave also learned their weaknesses: runtime cost, strict contract between caller and the callee and lack of type safety.Not to mention the problem of default type promotion!&lt;/p&gt;&lt;p&gt;Fortunately, standards committee thought this through and equipped us in C++11 with variadic templates. Let’s check themout.&lt;/p&gt;</description><link>https://kubasejdak.github.io/blog/variadic-functions--part-2-c11-variadic-templates/</link> <pubDate>Sat, 07 Jun 2025 22:56:12 +0000</pubDate><source url="https://kubasejdak.github.io/feed_rss_updated.xml">kubasejdak.com</source><guid isPermaLink="true">https://kubasejdak.github.io/blog/variadic-functions--part-2-c11-variadic-templates/</guid> <enclosure url="https://kubasejdak.github.io/assets/images/social/blog/posts/variadic-functions--part-2-c11-variadic-templates.png" type="image/png" length="54060" /> </item> <item> <title>Variadic functions – Part 3: Techniques of variadic templates</title> <author>Kuba Sejdak</author> <description>&lt;h1&gt;Variadic functions – Part 3: Techniques of variadic templates&lt;/h1&gt;&lt;p&gt;In the previous article I have shown you how variadic templates can be a type-safe alternative to va_arg macros indesigning the variadic functions. Today I want to show you a few techniques of variadic templates, that can be found inmany codebases.&lt;/p&gt;</description><link>https://kubasejdak.github.io/blog/variadic-functions--part-3-techniques-of-variadic-templates/</link> <pubDate>Sat, 07 Jun 2025 22:56:12 +0000</pubDate><source url="https://kubasejdak.github.io/feed_rss_updated.xml">kubasejdak.com</source><guid isPermaLink="true">https://kubasejdak.github.io/blog/variadic-functions--part-3-techniques-of-variadic-templates/</guid> <enclosure url="https://kubasejdak.github.io/assets/images/social/blog/posts/variadic-functions--part-3-techniques-of-variadic-templates.png" type="image/png" length="50054" /> </item> </channel></rss>